/* !
 * headroom.js v0.9.3 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2016 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */

!function(a, b) {'use strict'; 'function' == typeof define && define.amd ? define([], b) : 'object' == typeof exports ? module.exports = b() : a.Headroom = b();}(this, function() {'use strict'; function a(a) {this.callback = a, this.ticking = !1;} function b(a) {return a && 'undefined' != typeof window && (a === window || a.nodeType);} function c(a) {if (arguments.length <= 0) throw new Error('Missing arguments in extend function'); let d, e, f = a || {}; for (e = 1; e < arguments.length; e++) {let g = arguments[e] || {}; for (d in g)'object' != typeof f[d] || b(f[d]) ? f[d] = f[d] || g[d] : f[d] = c(f[d], g[d]);} return f;} function d(a) {return a === Object(a) ? a : { down: a, up: a };} function e(a, b) {b = c(b, e.options), this.lastKnownScrollY = 0, this.elem = a, this.tolerance = d(b.tolerance), this.classes = b.classes, this.offset = b.offset, this.scroller = b.scroller, this.initialised = !1, this.onPin = b.onPin, this.onUnpin = b.onUnpin, this.onTop = b.onTop, this.onNotTop = b.onNotTop, this.onBottom = b.onBottom, this.onNotBottom = b.onNotBottom;} let f = { bind: !!function() {}.bind, classList: 'classList'in document.documentElement, rAF: !!(window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame) }; return window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame, a.prototype = { constructor: a, update() {this.callback && this.callback(), this.ticking = !1;}, requestTick() {this.ticking || (requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this))), this.ticking = !0);}, handleEvent() {this.requestTick();} }, e.prototype = { constructor: e, init() {return e.cutsTheMustard ? (this.debouncer = new a(this.update.bind(this)), this.elem.classList.add(this.classes.initial), setTimeout(this.attachEvent.bind(this), 100), this) : void 0;}, destroy() {let a = this.classes; this.initialised = !1, this.elem.classList.remove(a.unpinned, a.pinned, a.top, a.notTop, a.initial), this.scroller.removeEventListener('scroll', this.debouncer, !1);}, attachEvent() {this.initialised || (this.lastKnownScrollY = this.getScrollY(), this.initialised = !0, this.scroller.addEventListener('scroll', this.debouncer, !1), this.debouncer.handleEvent());}, unpin() {let a = this.elem.classList, b = this.classes; !a.contains(b.pinned) && a.contains(b.unpinned) || (a.add(b.unpinned), a.remove(b.pinned), this.onUnpin && this.onUnpin.call(this));}, pin() {let a = this.elem.classList, b = this.classes; a.contains(b.unpinned) && (a.remove(b.unpinned), a.add(b.pinned), this.onPin && this.onPin.call(this));}, top() {let a = this.elem.classList, b = this.classes; a.contains(b.top) || (a.add(b.top), a.remove(b.notTop), this.onTop && this.onTop.call(this));}, notTop() {let a = this.elem.classList, b = this.classes; a.contains(b.notTop) || (a.add(b.notTop), a.remove(b.top), this.onNotTop && this.onNotTop.call(this));}, bottom() {let a = this.elem.classList, b = this.classes; a.contains(b.bottom) || (a.add(b.bottom), a.remove(b.notBottom), this.onBottom && this.onBottom.call(this));}, notBottom() {let a = this.elem.classList, b = this.classes; a.contains(b.notBottom) || (a.add(b.notBottom), a.remove(b.bottom), this.onNotBottom && this.onNotBottom.call(this));}, getScrollY() {return void 0 !== this.scroller.pageYOffset ? this.scroller.pageYOffset : void 0 !== this.scroller.scrollTop ? this.scroller.scrollTop : (document.documentElement || document.body.parentNode || document.body).scrollTop;}, getViewportHeight() {return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;}, getElementPhysicalHeight(a) {return Math.max(a.offsetHeight, a.clientHeight);}, getScrollerPhysicalHeight() {return this.scroller === window || this.scroller === document.body ? this.getViewportHeight() : this.getElementPhysicalHeight(this.scroller);}, getDocumentHeight() {let a = document.body, b = document.documentElement; return Math.max(a.scrollHeight, b.scrollHeight, a.offsetHeight, b.offsetHeight, a.clientHeight, b.clientHeight);}, getElementHeight(a) {return Math.max(a.scrollHeight, a.offsetHeight, a.clientHeight);}, getScrollerHeight() {return this.scroller === window || this.scroller === document.body ? this.getDocumentHeight() : this.getElementHeight(this.scroller);}, isOutOfBounds(a) {let b = 0 > a, c = a + this.getScrollerPhysicalHeight() > this.getScrollerHeight(); return b || c;}, toleranceExceeded(a, b) {return Math.abs(a - this.lastKnownScrollY) >= this.tolerance[b];}, shouldUnpin(a, b) {let c = a > this.lastKnownScrollY, d = a >= this.offset; return c && d && b;}, shouldPin(a, b) {let c = a < this.lastKnownScrollY, d = a <= this.offset; return c && b || d;}, update() {let a = this.getScrollY(), b = a > this.lastKnownScrollY ? 'down' : 'up', c = this.toleranceExceeded(a, b); this.isOutOfBounds(a) || (a <= this.offset ? this.top() : this.notTop(), a + this.getViewportHeight() >= this.getScrollerHeight() ? this.bottom() : this.notBottom(), this.shouldUnpin(a, c) ? this.unpin() : this.shouldPin(a, c) && this.pin(), this.lastKnownScrollY = a);} }, e.options = { tolerance: { up: 0, down: 0 }, offset: 0, scroller: window, classes: { pinned: 'headroom--pinned', unpinned: 'headroom--unpinned', top: 'headroom--top', notTop: 'headroom--not-top', bottom: 'headroom--bottom', notBottom: 'headroom--not-bottom', initial: 'headroom' } }, e.cutsTheMustard = 'undefined' != typeof f && f.rAF && f.bind && f.classList, e;});
